# Merkle Patricia Verifier - Solidity Implementation

Solidity implementation of a Merkle Patricia Trie inclusion proof verifier, compatible with the Metakit project.

## Overview

This implementation provides on-chain verification of Merkle Patricia inclusion proofs generated by the Scala backend. It's optimized for gas efficiency while maintaining compatibility with the JSON proof format.

## Contracts

### MerklePatriciaVerifier.sol

The main verifier contract that implements the verification logic for Merkle Patricia Trie proofs.

**Key Features:**
- Gas-optimized with custom errors instead of require statements
- Binary prefixes for node type distinction (matching Scala implementation)
- Support for all three node types: Leaf, Branch, and Extension
- Deterministic JSON canonicalization for hash verification

### ExampleUsage.sol

Demonstrates how to use the verifier with test data from the Metakit project.

## Gas Costs

Estimated gas costs for typical proofs:

| Proof Type | Witness Depth | Estimated Gas |
|------------|---------------|---------------|
| Simple     | 3 nodes       | 80-120k       |
| Medium     | 4-5 nodes     | 120-180k      |
| Complex    | 8-10 nodes    | 250-400k      |

The 10-fingerprint proof example (3 nodes with extension optimization) costs approximately **100k gas**.

## Usage

```solidity
// Deploy the verifier
MerklePatriciaVerifier verifier = new MerklePatriciaVerifier();

// Create proof structure
MerklePatriciaVerifier.InclusionProof memory proof = MerklePatriciaVerifier.InclusionProof({
    path: pathHash,
    witness: witnessArray
});

// Verify the proof
bool isValid = verifier.verify(rootHash, proof);
```

## Proof Encoding

The proof data must be encoded for on-chain verification:

### Leaf Node
```solidity
bytes memory leafData = abi.encodePacked(
    uint8(remaining.length),  // Length of remaining nibbles
    remaining,                 // Remaining path nibbles
    dataDigest                // SHA-256 hash of the data
);
```

### Extension Node
```solidity
bytes memory extensionData = abi.encodePacked(
    uint8(shared.length),     // Length of shared nibbles
    shared,                   // Shared path nibbles
    childDigest              // SHA-256 hash of child node
);
```

### Branch Node
```solidity
bytes memory branchData = abi.encodePacked(
    uint8(numPaths),         // Number of paths in branch
    nibble1, digest1,        // First path: nibble + digest
    nibble2, digest2,        // Second path: nibble + digest
    ...                      // Additional paths
);
```

## Implementation Notes

### JSON Canonicalization

The contract implements deterministic JSON serialization matching RFC 8785:
- Object keys are sorted alphabetically
- No whitespace between elements
- Lowercase hex encoding for consistency

### Nibble Handling

Paths are represented as nibbles (4-bit values):
- Each byte of a hash becomes two nibbles
- Nibbles are stored as single bytes for gas efficiency
- Hex characters are converted: '0'-'9' = 0-9, 'a'-'f' = 10-15

### Security Considerations

1. **Hash Verification**: All node commitments are verified using SHA-256
2. **Path Validation**: Ensures paths match at each level of the trie
3. **Type Safety**: Uses enums for node types to prevent invalid states
4. **Gas Limits**: Consider implementing depth limits for production use

## Testing

Deploy and test using Hardhat or Foundry:

```bash
# Using Hardhat
npx hardhat test

# Using Foundry
forge test
```

## Compatibility

This implementation is designed to be compatible with:
- Metakit Scala `OptimizedMerklePatriciaProducer`
- JSON proofs exported from the Scala backend
- Standard SHA-256 hashing with binary prefixes

## Optimization Opportunities

For production deployments, consider:
1. **Batch Verification**: Verify multiple proofs in a single transaction
2. **Caching**: Store verified roots to avoid re-verification
3. **Assembly Optimization**: Use inline assembly for critical paths
4. **Storage Patterns**: Use merkle proof registries for frequently verified data

## License

MIT